   浏览器从下载页面到显示是个复杂的过程，这里包含了重绘和重排。各家浏览器引擎的工作原理略有差别，但也有一定规则。
   简单讲，文档在初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属  性，类似盒子模型（由于隐藏元素不需要展示，渲染树种并不包括DOM树种隐藏的元素）。当渲染树构建完成以后，浏览器就可以将元素放到正确的位置上了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。
   重绘是一个元素外观的改变所触发的浏览器行为。例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。
   重排是更明显的一种改变，可以理解为渲染树需要重新计算。  
### 触发重排的操作有：
（1）DOM元素的几何属性的变化。
    当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重新构建渲染树中失效的节点。之后，会根据新的渲染树重新绘制这部分页面。
而且，当前元素的重排也许会带来相关元素的重排。例如，容器节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点的重排，祖先节点需要重新计算
子节点的尺寸也会产生重排。最后，每个元素都将发生重绘。可见，重排一定会引起浏览器的重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的
重排和重绘，性能代价是高昂的。
（2）DOM树的结构变化
    当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器引擎布局的过程，类似于树的前序遍历，是一个从上到下从左到右的过程。通常在这个过程中，
当前元素不会再影响其前面已经遍历过的元素。所以，如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元素，则不会影响到前面的元素。
（3）获取某些属性。
offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、
clientHeight、getComputedStyle() (currentStyle in IE)。多次使用这些值，应该进行缓存。
（4）改变元素的一些样式，调整浏览器窗口大小等等也都将触发重排。

### 还有一些影响性能的操作：
（1）IE允许在任何元素使用hover这个css伪选择器，然而如果你大量元素使用hover，那么会降低响应速度，在IE8更为明显。

开发中应该尽量减少重绘和重排的次数，缩小影响范围，减少的方法有：
（1）在操作元素样式的时候不要一个个单独赋值，可以用css写到一个类里面，然后给该元素添加这个类。或者：
div.style.cssText="border-left:1px;border-right:2px;padding:5px;"
（2）有动画的元素尽量绝对定位或者固定定位，这位绝对定位和固定定位就脱离了文档流，它的变化不会影响到其他元素。
（3）在内存中多次操作结点，完成后再添加到文档中去。例如通过ajax获取到的数据，可以现在内存中构建整个的html片段，再一次性添加到文档中去，而不是循环添加
每一行。
（4）display为none的元素不在渲染树中，对隐藏元素的操作不会影响其他元素的重排。如果要对一个元素进行负责的操作，可以先隐藏它，操作完以后再显示它，这样
只在隐藏和显示的时候进行两次重排。
（5）在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。如：
offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、
clientHeight、getComputedStyle() (currentStyle in IE)。浏览器为取得正确的值也会触发重排，所以，在多次使用这些值时应进行缓存。

（参考http://kb.cnblogs.com/page/169820/）


### DOM操作原则总结：  
（参考：https://baijiahao.baidu.com/s?id=1565562510394984&wfr=spider&for=pc）
最小化DOM的访问次数。
多次访问某个DOM节点，使用局部变量存储它的引用。
小心处理HTML集合。
使用速度更快的API，比如querySelectorAll()
要留意重绘和重排，批量修改样式，离线操作DOM树。
使用缓存，并减少访问布局信息的次数
动画中使用绝对定位
使用拖放代理
使用事件委托来减少事件处理器的数量



### 事件委托：  
(参考：http://www.cnblogs.com/liugang-vip/p/5616484.html 讲的很好)
为什么要用事件委托：  
    一般来说DOM需要事件处理程序，我们直接给它设置事件处理程序就好了，那如果很多DOM需要事件处理程序呢，比如我们有100个li，每个li都有相同的click点击事件，我们可以用for循环来遍历所有的li，给它添加事件，这样做的弊端是：添加到页面中的事件处理程序的数量将会影响页面的整体性能，因为需要不断地与DOM节点交互，访问DOM节点的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因，
如果用事件委托，就会将所有的操作放到js程序里面，与DOM的交互操作就只需要进行一次，这样大大减少与DOM的交互次数，提高性能。
    
   每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。  
### 事件委托的原理：
   事件委托是利用事件冒泡实现的，点击一个元素，它会从最深层网上冒泡，例如：div>ul>li>a; 冒泡的顺序为a>li>ul>div，就是说，点击a标签的事件会一直冒泡到div标签，这样我们给最外层的div添加点击事件，当里面的ul,li,a标签做点击的时候，由于冒泡原理，div上添加的点击事件都会触发，这就是事件委托，委托他们的父级代为执行事件。

